---
title: "Spring AI 与 MCP（Model Context Protocol）"
date: 2026-02-06
slug: spring-ai-mcp
categories: ["ai"]
tags: ['spring-ai', 'mcp']
---

本文结合本仓库中的示例代码，介绍 **MCP（Model Context Protocol）** 是什么，以及如何在 Spring AI 中实现 **MCP Server** 与 **MCP Client**，让大模型通过标准协议调用你暴露的「工具」与数据。

<!--more-->

> **示例代码库**
>
> MCP 相关示例位于：  
> - [10-mcp-server-stdio](https://github.com/chensoul/spring-ai-samples/tree/main/10-mcp-server-stdio)（STDIO 服务端）  
> - [11-mcp-client-stdio](https://github.com/chensoul/spring-ai-samples/tree/main/11-mcp-client-stdio)（STDIO 客户端）  
> - [12-mcp-server-webflux](https://github.com/chensoul/spring-ai-samples/tree/main/12-mcp-server-webflux)（SSE/WebFlux 服务端）  
> - [13-mcp-client-webflux](https://github.com/chensoul/spring-ai-samples/tree/main/13-mcp-client-webflux)（SSE 客户端）

## 什么是 MCP

**MCP（Model Context Protocol）** 是一套开放协议，用于把 **AI 应用** 和 **外部能力** 连在一起：数据源、工具、工作流等。可以把它理解成「AI 的通用接口」：  
- **服务端**：暴露工具（Tools）、资源（Resources）、提示模板（Prompts）等。  
- **客户端**：AI 应用按协议连接服务端，发现并调用这些能力，再结合大模型生成回答。

这样，模型不仅能对话，还能按需查库、调 API、执行你定义的操作；协议统一后，同一套 MCP 服务可被不同客户端（Claude、ChatGPT、自建应用等）复用。

本仓库用 **Spring AI** 实现了两类传输方式：**STDIO**（进程间，适合本地/CLI）和 **SSE**（HTTP，适合远程/浏览器）。

## 本仓库中的四个模块

| 模块 | 角色 | 传输 | 说明 |
|------|------|------|------|
| **10-mcp-server-stdio** | MCP Server | STDIO | 无 HTTP，标准输入/输出，由客户端进程启动 |
| **11-mcp-client-stdio** | MCP Client | STDIO | 通过 `mcp-servers.json` 配置，启动 10 的 jar 并通信 |
| **12-mcp-server-webflux** | MCP Server | SSE (HTTP) | 端口 8181，提供 `/sse` 等端点 |
| **13-mcp-client-webflux** | MCP Client | SSE | 通过配置连接 11 的 URL，如 `http://localhost:8181` |

**搭配关系**：10 ↔ 11（STDIO）；12 ↔ 13（SSE）。服务端暴露「视频目录」相关工具（查全部、按标题搜索、按标题取一条）；客户端用 DeepSeek 等模型 + 这些工具回答用户问题。

## MCP Server：用 @Tool 暴露能力

服务端把「能力」定义为 **Tools**，每个工具对应一个可被调用的方法。Spring AI 中沿用 **@Tool** 注解，并通过 **ToolCallbacks** 注册给 MCP 层。

### 工具定义（VideoTools）

与 09-tool-calling 类似，用 **@Tool** 标注方法，并写清 `name` 与 `description`，MCP 会据此生成协议所需的 schema：

```java
@Component
public class VideoTools {
    private final VideoRepository videoRepository;

    @Tool(name = "get_all_videos", description = "Get all videos")
    public List<Video> getAllVideos() {
        return videoRepository.findAll();
    }

    @Tool(name = "search_videos", description = "Search videos by title")
    public List<Video> searchVideos(String title) {
        return videoRepository.findByTitleContainingIgnoreCase(title);
    }

    @Tool(name = "get_video_by_title", description = "Get a single video by title")
    public Video getVideoByTitle(String title) {
        return videoRepository.findByTitle(title).orElse(null);
    }
}
```

`Video` 为普通 JPA 实体（id、title、url）；数据由 `schema.sql` 初始化（H2）。

### 注册为 MCP 的 ToolCallback（10 / 12 共用写法）

在启动类中把上述工具包装成 **ToolCallback** 列表并交给 Spring AI MCP：

```java
@SpringBootApplication
public class McpServerStdioApplication {

    @Bean
    public List<ToolCallback> toolCallbacks(VideoTools videoTools) {
        return List.of(ToolCallbacks.from(videoTools));
    }
}
```

**10** 与 **12** 的 Java 代码结构一致，差异只在**传输方式与运行模式**：10 使用 STDIO 传输且不启动 Web；12 使用 WebFlux 并暴露 SSE 端点。

### 10：STDIO 服务端配置

- 应用类型设为 **non-web**，关闭 Banner 与控制台日志，以便 STDIO 读写不被干扰。
- 开启 MCP STDIO 并设置服务名：

```properties
spring.main.web-application-type=none
spring.ai.mcp.server.name=mcp-server-stdio
spring.ai.mcp.server.version=0.0.1
spring.ai.mcp.server.stdio=true

spring.main.banner-mode=off
```

客户端（或 MCP Inspector）通过「启动进程 + 标准输入/输出」与之通信，例如：  
`java -jar 10-mcp-server-stdio.jar`。

### 12：SSE/WebFlux 服务端配置

- 正常 Web 应用，端口 8181。
- 只配置 MCP 服务名与版本，传输由 Spring AI MCP WebFlux starter 提供（如 `/sse`）：

```properties
server.port=8181
spring.ai.mcp.server.name=mcp-server-webflux
spring.ai.mcp.server.version=0.0.1
```

客户端通过 URL（如 `http://localhost:8181`）连接即可。

## MCP Client：把 MCP 工具注入 ChatClient

客户端侧：**连接 MCP Server** → 获取其暴露的 **Tools** → 将这些工具作为 **ToolCallbackProvider** 注入 **ChatClient**，这样模型在回答时会自动选择并调用 MCP 工具。

### 11：STDIO 客户端

- **依赖**：`spring-ai-starter-mcp-client` + `spring-ai-starter-model-openai`（本示例用 DeepSeek）。
- **配置**：在 `mcp-servers.json` 中声明要启动的 MCP 进程（命令 + 参数）：

```json
{
  "mcpServers": {
    "video-server": {
      "command": "java",
      "args": ["-jar", "path/to/10-mcp-server-stdio/target/10-mcp-server-stdio.jar"]
    }
  }
}
```

`path/to/...` 需替换为实际 jar 路径。  
应用属性中指定该配置并配置模型：

```properties
spring.ai.mcp.client.stdio.servers-configuration=classpath:mcp-servers.json

spring.ai.openai.base-url=https://api.deepseek.com
spring.ai.openai.api-key=${DEEPSEEK_API_KEY}
spring.ai.openai.chat.options.model=deepseek-reasoner
```

运行时，客户端会按配置启动 10 的 jar，通过 STDIO 与 MCP Server 通信，并把得到的工具注册到 ChatClient。

### 13：SSE 客户端

- **依赖**：`spring-ai-starter-mcp-client-webflux` + `spring-ai-starter-model-openai`。
- **配置**：直接写 MCP Server 的 URL（对应 12），无需启动子进程：

```properties
spring.ai.mcp.client.sse.connections.video-server.url=http://localhost:8181

spring.ai.openai.base-url=https://api.deepseek.com
spring.ai.openai.api-key=${DEEPSEEK_API_KEY}
spring.ai.openai.chat.options.model=deepseek-reasoner
```

先启动 **12-mcp-server-webflux**，再启动 **13-mcp-client-webflux**，即可通过 HTTP/SSE 使用同一套视频工具。

### 客户端业务代码（11 与 12 共用）

控制器中注入 **ChatClient.Builder** 与 **ToolCallbackProvider**（MCP 工具会由 Spring AI 通过该 Provider 注入）：

```java
@RestController
public class VideoController {
    private final ChatClient chatClient;

    public VideoController(ChatClient.Builder chatClientBuilder,
                           ToolCallbackProvider tools) {
        this.chatClient = chatClientBuilder
                .defaultAdvisors(new SimpleLoggerAdvisor())
                .defaultToolCallbacks(tools)
                .build();
    }

    @PostMapping("/ask")
    public Answer ask(@RequestBody Question question) {
        var response = chatClient.prompt().user(question.question()).call().content();
        // 可选：再调一次模型做格式化为 Markdown/HTML
        var htmlResponse = MarkdownHelper.toHTML(formatResponse(question, response));
        return new Answer(htmlResponse);
    }

    record Question(String question) {}
    record Answer(String answer) {}
}
```

用户提问 → ChatClient 携带 MCP 工具调用模型 → 模型决定是否调用 `get_all_videos`、`search_videos` 等 → 框架执行工具并把结果回传给模型 → 模型生成最终回复。

## 用 MCP Inspector 调试

不写客户端也能验证 Server 是否按协议暴露工具：

- **10（STDIO）**：  
  - 运行 `npx @modelcontextprotocol/inspector@latest`  
  - Transport 选 **STDIO**，Command 填 `java`，Arguments 填 `-jar /path/to/10-mcp-server-stdio.jar`  
  - Connect 后可在 Tools 中列出并调用 `get_all_videos` 等。

- **12（SSE）**：  
  - 先启动 12，再在 Inspector 中选 **SSE**，URL 填 `http://localhost:8181/sse` （以实际文档为准）  
  - 同样可 List Tools / Invoke Tools。

## 运行前准备

- **DeepSeek**：11 和 13 默认用 DeepSeek，需设置环境变量 `DEEPSEEK_API_KEY`。
- **10 / 12**：若使用 H2 + `schema.sql`，需保证应用能执行建表与初始数据（如 `spring.sql.init.mode=always` 等，视版本而定）。
- **11**：`mcp-servers.json` 中的 jar 路径必须指向已打包的 10 的 jar。

## 小结

- **MCP** 是连接 AI 应用与外部工具/数据的开放协议；**Server** 暴露工具，**Client** 连接并把这些工具提供给模型。
- **Spring AI** 中：Server 用 **@Tool** + **ToolCallbacks.from(...)** 暴露能力；Client 用 **ToolCallbackProvider** + **defaultToolCallbacks(tools)** 把 MCP 工具注入 ChatClient。
- 本仓库提供 **STDIO**（10 + 11）与 **SSE/WebFlux**（12 + 13）两套传输，可按部署方式选用；两套共用同一套「视频目录」工具与 DeepSeek 配置，便于对照理解 MCP 在 Spring AI 中的用法。
